# Поймай падающие фрукты — краткая справка

Небольшая игра на Cocos Creator 3: игрок управляет корзиной, ловит падающие предметы (Good / Bad) за ограниченный промежуток времени. За хорошие предметы дают очки, за плохие теряются жизни.

## Структура проекта (основные файлы)
- **GameManager.ts** — основная доменная логика: счёт, таймер, жизни (сердечки), цикл спавна; подписывается на события о поимках.
- **GameEvents.ts** — набор событий (enum): SPAWN_FRUIT, GAME_OVER, FALLING_ITEM_MISSED, GOOD_FALLING_ITEM_CAUGHT, BAD_FALLING_ITEM_CAUGHT.
- **FallingItemSpawner.ts** — отвечает за спавн и рециклинг падающих предметов; использует ItemPool; подписан на SPAWN_FRUIT и GAME_OVER.
- **ItemPool.ts** — обёртка над NodePool (реализация пула для префабов).
- FallingItems/
    - **FallingItem.ts** — базовый компонент падающего предмета: падение, вычисление границы пропуска, логика поимки + анимация; эмитит событие FALLING_ITEM_MISSED, когда item ушел за границу дозволенного (missY).
    - **GoodFallingItem.ts** — наследник FallingItem, при поимке эмитит GOOD_FALLING_ITEM_CAUGHT.
    - **BadFallingItem.ts** — наследник FallingItem, при поимке эмитит BAD_FALLING_ITEM_CAUGHT.
- **BasketController.ts** — управление корзиной (ввод клавишами, ограничение по границе, обработка коллизий); при коллизии вызывает onCaught() у FallingItem.

## Принятые архитектурные решения
1. Событийная шина через node.scene.emit/on (GameEvents) — слабосвязанная коммуникация между Spawner, GameManager и FallingItem.
2. Пулы для префабов (ItemPool → NodePool) — минимизация аллокаций/GC при частом спавне.
3. Чистое разделение ответственности (SRP): спавнер — только спавн/рециклинг; менеджер — состояние игры; item — поведение падения и поимки; корзина — ввод/коллизии.
4. Базовый класс FallingItem + наследники Good/Bad — простая модель расширения типов предметов через переопределение реакции на поимку.

## Известные ограничения и замечания
- Глобальная шина событий (node.scene) удобна, но усложняет трассировку и модульное тестирование (высокая скрытая связанность).
- GameManager всё ещё напрямую манипулирует UI (Label, Node для gameOver и hearts) — затрудняет переиспользование логики без сцены.
- Магические константы (таймер, координаты missY, spacing для сердечек) захардкожены в коде.
- Наследование для типов предметов хорошо для небольшой линии, но при росте типов выгоднее композиция/стратегии.
- Отсутствуют явные интерфейсы/контракты (например ISpawner, IFallingItem, IScoreSystem) — это усложняет заменяемость и тестирование.
- Нет конфигурации уровня/сложности (динамическое изменение частоты/скорости спавна и скорости падения items).

## Что можно сделать дальше (план улучшений)
1. Ввести явные интерфейсы (ISpawner, IFallingItem, IScoreSystem) и dependency injection через ссылки на компоненты — уменьшит связанность и упростит тестирование.
2. Рассмотреть замену node.scene-events на локальный EventBus / Mediator или централизованный GameService с явными подписками — улучшит трассируемость и управление жизненным циклом.
3. Вынести UI в отдельный GameUIController: GameManager управляет состоянием, UI — только визуализирует.
4. Вынести конфигурации (таймер, стартовые жизни, параметры спавна, магические числа) в единый конфиг/ScriptableObject, добавить настройку сложности.
5. Рассмотреть ECS-подход для FallingItem, если ожидается рост числа типов/поведений или высокая плотность объектов:
    - ECS даёт композицию вместо наследования, облегчает пакетную обработку (Movement, Lifecycle) и потенциально повышает производительность при большом количестве элементов.
    - Компоненты (пример): Position, Velocity/Falling, Renderable (ссылка на Node), Collectable (isCaught), ItemType.
    - Системы (пример): MovementSystem, Collision/CollectSystem (помечает Collectable), ItemLifecycleSystem (miss, recycle через пул), SpawnSystem, RenderSyncSystem (Position → Node).
