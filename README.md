# Поймай падающие фрукты — краткая справка

Небольшой проект на Cocos Creator 3: ловите падающие предметы корзиной за ограниченное время, набирайте очки, теряйте жизни за опасные предметы.

## Структура проекта (основные файлы)
- src/
  - GameManager.ts — доменная логика игры: очки, таймер, жизни, UI-обновления, цикл спавна.
  - FruitSpawner.ts — отвечает за создание/рециклинг фруктов, держит пулы (FruitPool), слушает события SPAWN_FRUIT / GAME_OVER.
  - FruitPool.ts — обёртка над NodePool для повторного использования префабов.
  - FallingItems/
    - FallingItem.ts — базовый компонент падающего предмета: падение, граница промаха, логика поимки/анимация.
    - GoodFallingItem.ts — наследник FallingItem, эмиттит событие GOOD_FALLING_ITEM_CAUGHT при поимке.
    - BadFallingItem.ts — наследник FallingItem, эмиттит событие BAD_FALLING_ITEM_CAUGHT при поимке.
  - BasketController.ts — управление корзиной (клавиши влево/вправо), обработка коллизий с FallingItem.
  - GameEvents.ts — набор строковых констант (enum) для событий: SPAWN_FRUIT, GAME_OVER, FALLING_ITEM_MISSED, GOOD/BAD_FALLING_ITEM_CAUGHT.

## Принятые архитектурные решения (обоснование)
1. Событийная шина (node.scene.emit / on)
   - Компоненты общаются через GameEvents — это снижает прямые зависимости между spawner, manager и фруктами.
2. Объектный пул (FruitPool / NodePool)
   - Для уменьшения расходов на инстанциирование/удаление Node используются пулы — важно для производительности мобильных игр.
3. Разделение ответственности (SRP)
   - Каждый компонент имеет узкую ответственность: спавнер — спавн и рециклинг, менеджер — состояние игры и UI, корзина — ввод и коллизии, фрукт — поведение падения/поимки.
4. Наследование для вариативности предметов
   - Базовый FallingItem инкапсулирует общее поведение; Good/Bad реализуют различную реакцию на поимку через события.

## Известные ограничения / замечания
- Глобальная событийная шина (node.scene) — удобна, но повышает связность и усложняет трассировку потоков данных и тестирование.
- Жёсткая связь GameManager с UI (прямые обращения к Label/Node) — затрудняет переиспользование логики без сцены/контроллера UI.
- Магические константы (высоты, смещения, тайминги) и частые обращения к Node/Component без полной проверки null — риск ошибок на разных сценах/разрешениях.
- В current коде используется наследование для разных типов предметов; при росте набора типов это может привести к большому дереву наследования.
- Нет абстракций для систем (например, ISpawner, IScoreSystem), что усложняет модульное тестирование.
- Отсутствуют интеграционные/юнит-тесты и конфигурация сложности (динамическое изменение частоты/скорости спавна).

## Что можно сделать дальше (план улучшений)
1. Ввести явные интерфейсы/контракты (например, ISpawner, IFallingItem, IScoreSystem) и инъекцию зависимостей через ссылки на компоненты — это уменьшит связанность и упростит тестирование.
2. Заменить (или инкапсулировать) node.scene-events на локальный EventBus / Mediator или централизованный GameService для лучшей трассируемости.
3. Вынести UI в отдельный контроллер (GameUIController) — GameManager должен управлять состоянием, а не обновлением визуальных компонентов.
4. Перейти от широкого использования наследования к композиции (напр., поведение поимки как Strategy/Component), если появится много типов предметов.
5. Добавить конфигурацию уровня / прогрессию сложности (увеличение скорости/частоты), мобильный ввод (тап/перетягивание) и набор тестов для основных бизнес-правил.
6. Улучшить обработку границ/разрешений (адаптивная логика на разных экранах) и убрать "магические числа" в конфиг.

---

Если нужно, могу:
- Сгенерировать конкретный план рефакторинга и показать пример с интерфейсами и инверсией зависимостей.
- Подготовить патч/PR с выделением UI-контроллера и введением EventBus.
